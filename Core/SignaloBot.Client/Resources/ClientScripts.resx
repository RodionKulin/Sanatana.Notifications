<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="foreignKeyIndex_UserCategorySettings_CategoryID" xml:space="preserve">
    <value>CREATE NONCLUSTERED INDEX [IX_CategoryID] ON [dbo].[pref_UserCategorySettings] ([CategoryID])</value>
  </data>
  <data name="foreignKeyIndex_UserTopicSettings_CategoryID" xml:space="preserve">
    <value>CREATE NONCLUSTERED INDEX [IX_CategoryID] ON [dbo].[pref_UserTopicSettings] ([CategoryID])</value>
  </data>
  <data name="index_UserCategorySettings_CategoryID" xml:space="preserve">
    <value>CREATE INDEX [IX_pref_UserCategorySettings_CategoryID] ON [dbo].[pref_UserCategorySettings]([CategoryID])</value>
  </data>
  <data name="index_UserDeliveryTypeSettings_Address" xml:space="preserve">
    <value>CREATE UNIQUE NONCLUSTERED INDEX [IX_pref_UserDeliveryTypeSettings_Address]
ON [dbo].[pref_UserDeliveryTypeSettings]([Address]) WHERE [Address] IS NOT NULL</value>
  </data>
  <data name="index_UserTopicSettings_CategoryID" xml:space="preserve">
    <value>CREATE INDEX [IX_pref_UserTopicSettings_CategoryID] ON [dbo].[pref_UserTopicSettings]([CategoryID])</value>
  </data>
  <data name="proc_Address_Exists" xml:space="preserve">
    <value>CREATE PROCEDURE [dbo].[pref_Address_Exists]
	@Address NVARCHAR(1000),
	@DeliveryType INT
AS

SELECT 1 as AddressExists WHERE
EXISTS 
	(SELECT 1 FROM pref_UserDeliveryTypeSettings
	WHERE Address = @Address
	AND DeliveryType = @DeliveryType)
</value>
  </data>
  <data name="proc_UserDeliveryTypeSettings_SelectAll" xml:space="preserve">
    <value>CREATE PROCEDURE [dbo].[pref_UserDeliveryTypeSettings_SelectAll]	
	@FirstIndex INT,
	@LastIndex INT
AS

SELECT sub.UserID, sub.DeliveryType, sub.Address, sub.TimeZoneID,
	sub.LastUserVisitUtc, sub.LastSendDateUtc, sub.IsEnabled, sub.IsEnabledOnNewTopic, sub.SendCount,
	sub.NDRCount, sub.IsBlockedOfNDR, sub.BlockOfNDRResetCodeSendDateUtc, sub.BlockOfNDRResetCode,
	up + down - 1 AS TotalRows FROM
(	
	SELECT s.*,
		ROW_NUMBER() OVER(ORDER BY s.UserID) AS up,
		ROW_NUMBER() OVER(ORDER BY s.UserID DESC) AS down
	FROM pref_UserDeliveryTypeSettings s		
) AS sub
WHERE sub.down BETWEEN @FirstIndex AND @LastIndex</value>
  </data>
  <data name="proc_UserReceivePeriods_Rewrite" xml:space="preserve">
    <value>CREATE PROCEDURE [dbo].[pref_UserReceivePeriods_Rewrite]
	@UserID UNIQUEIDENTIFIER,
	@DeliveryType INT,
	@CategoryID INT,
	@Periods pref_UserReceivePeriodType READONLY
AS

DELETE pref_UserReceivePeriods
WHERE UserID = @UserID
AND DeliveryType = @DeliveryType
AND CategoryID = @CategoryID

INSERT pref_UserReceivePeriods (UserID, DeliveryType, CategoryID, PeriodOrder, PeriodBegin, PeriodEnd)
SELECT @UserID, @DeliveryType, @CategoryID, PeriodOrder, PeriodBegin, PeriodEnd
FROM @Periods</value>
  </data>
  <data name="proc_UserTopicSettings_Insert" xml:space="preserve">
    <value>CREATE PROCEDURE [dbo].[pref_UserTopicSettings_Insert]
	@UserID UNIQUEIDENTIFIER,
	@DeliveryType INT,
	@CategoryID INT,
	@TopicID INT,
	@ForceIfDeleted BIT,
	@IsEnabledOnNewTopic BIT
AS

IF @IsEnabledOnNewTopic IS NULL
BEGIN
	SELECT @IsEnabledOnNewTopic = IsEnabledOnNewTopic
	FROM pref_UserDeliveryTypeSettings
	WHERE UserID = @UserID
	AND DeliveryType = @DeliveryType
END

IF @IsEnabledOnNewTopic IS NULL
BEGIN
	DECLARE @ExceptionMessage NVARCHAR(2048) = 'User with UserID ' + convert(nvarchar(50), @UserID) + ' and DeliveryType ' + @DeliveryType + ' not found in UserTopicSettings table.';
	THROW 101000, @ExceptionMessage, 1;
END

IF @ForceIfDeleted = 1
BEGIN

	MERGE pref_UserTopicSettings AS TARGET
	USING (SELECT @UserID AS UserID) AS SOURCE
	ON TARGET.UserID = SOURCE.UserID
		AND TARGET.DeliveryType = @DeliveryType
		AND TARGET.CategoryID = @CategoryID
		AND TARGET.TopicID = @TopicID
	WHEN MATCHED THEN UPDATE SET
		TARGET.IsEnabled = @IsEnabledOnNewTopic,
		TARGET.IsDeleted = 0,
		TARGET.AddDateUtc = GETUTCDATE()
	WHEN NOT MATCHED BY TARGET THEN
		INSERT (UserID, DeliveryType,CategoryID, TopicID, AddDateUtc, LastSendDateUtc, SendCount, IsEnabled, IsDeleted)
		VALUES (SOURCE.UserID, @DeliveryType, @CategoryID, @TopicID, GETUTCDATE(), NULL, 0, @IsEnabledOnNewTopic, 0);
END
ELSE
BEGIN

	MERGE pref_UserTopicSettings AS TARGET
	USING (SELECT @UserID AS UserID) AS SOURCE
	ON TARGET.UserID = SOURCE.UserID
		AND TARGET.DeliveryType = @DeliveryType
		AND TARGET.CategoryID = @CategoryID
		AND TARGET.TopicID = @TopicID
	WHEN NOT MATCHED BY TARGET THEN
		INSERT (UserID, DeliveryType,CategoryID, TopicID, AddDateUtc, LastSendDateUtc, SendCount, IsEnabled, IsDeleted)
		VALUES (SOURCE.UserID, @DeliveryType,@CategoryID, @TopicID, GETUTCDATE(), NULL, 0, @IsEnabledOnNewTopic, 0);
END</value>
  </data>
  <data name="proc_UserTopicSettings_Select" xml:space="preserve">
    <value>CREATE PROCEDURE [dbo].[pref_UserTopicSettings_Select]
	@UserID UNIQUEIDENTIFIER,
	@DeliveryType INT,
	@FirstIndex INT,
	@LastIndex INT,
	@CategoryIDs pref_IntType READONLY
AS

SELECT sub.UserID, sub.DeliveryType, sub.CategoryID, sub.TopicID,
	sub.AddDateUtc, sub.SendCount, sub.IsEnabled,
	up + down - 1 AS TotalRows FROM
(	
	SELECT s.*,
		ROW_NUMBER() OVER(ORDER BY s.AddDateUtc) AS up,
		ROW_NUMBER() OVER(ORDER BY s.AddDateUtc DESC) AS down
	FROM pref_UserTopicSettings s
	JOIN @CategoryIDs c ON c.ID = s.CategoryID
	WHERE s.UserId = @UserId
	AND s.DeliveryType = @DeliveryType
	AND s.IsDeleted = 0
) AS sub
WHERE sub.down BETWEEN @FirstIndex AND @LastIndex</value>
  </data>
  <data name="type_Category" xml:space="preserve">
    <value>CREATE TYPE [dbo].[pref_CategoryType] AS TABLE(
	[CategoryID] INT            NOT NULL,
    [Name]       NVARCHAR (MAX) NOT NULL
)</value>
  </data>
  <data name="type_Guid" xml:space="preserve">
    <value>CREATE TYPE [dbo].[pref_GuidType] AS TABLE(
	[ID] [uniqueidentifier] NOT NULL
)</value>
  </data>
  <data name="type_Int" xml:space="preserve">
    <value>CREATE TYPE [dbo].[pref_IntType] AS TABLE(
	[ID] [int] NOT NULL
)</value>
  </data>
  <data name="type_UpdateUserType" xml:space="preserve">
    <value>CREATE TYPE [dbo].[pref_UpdateUserType] AS TABLE(
	[UserID] [uniqueidentifier] NOT NULL,
	[SendCount] [int] NOT NULL,
	[DeliveryType] [int] NOT NULL,
	[CategoryID] [int] NOT NULL,
	[TopicID] [int] NULL
)</value>
  </data>
  <data name="type_UserReceivePeriod" xml:space="preserve">
    <value>CREATE TYPE [dbo].[pref_UserReceivePeriodType] AS TABLE(
	[PeriodOrder] [int] NOT NULL,
	[PeriodBegin] [Time] NOT NULL,
	[PeriodEnd] [Time] NOT NULL
)</value>
  </data>
</root>